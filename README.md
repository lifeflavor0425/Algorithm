# Algorithm

프로그래머스 or 백준

# DFS | BFS

## DFS가 유리한 경우

- 재귀적인 특징과 백트래킹을 이용하여 모든 경우를 하나씩 전부 탐색하는 경우
- Graph의 크기가 클 경우
- Optimal(효율, 최적)한 답을 찾는 것이 아닌 경우
- 경로의 특징을 저장해야 하는 경우 ex) 경로의 가중치, 이동 과정, 깊이 등..

## BFS가 유리한 경우

- 최단 거리 or 최단 횟수
- Optimal(효율, 최적)한 답을 찾는 경우, BFS는 가장 처음 발견되는 해답이 최단 거리

# 백트래킹

## 재귀함수 + for 문

- 모든 경우의 수를 확인해야 할 때
- for로는 확인 불가능한 경우(깊이가 달라질 때)
- ex) 순열 : 1,2,3 중에 2개를 고를 경우(1,2 / 1,3 / 2,1 / 2,3 / 3,1 / 3,2)
- TIP) N 값이 작아야함(중복 가능 : 8이하, 중복 x : 10이하)
- TIP) 재귀함수 사용할 때, 종료 시점 잊지 말기

# 시뮬레이션

- 각 조건에 맞는 상황을 구현하는 문제
  - 지도상에서 이동하면서 탐험? 하는 문제
  - 배열 안에서 이동하면서 탐험? 하는 문제
  - 배열 끼리 값을 교환하는 문제
- 별도의 알고리즘 없이 풀 수 있으나, 구현력 중요!
- TIP) 주어진 조건을 되도록 그대로 구현
- TIP) 되도록 쉽게 구현

# 투포인터

- 각 원소마다 모든 값을 순회해야 할 때
- 연속하다는 특성을 이용
- 처음부터 생각하기 어려움

# 이진트리

- 어떤 값을 찾을 때 정렬의 특징을 이용해 빨리 찾음
- 정렬되어 있을 경우, 어떤 값을 찾을 때 : O(N) -> O(lgN)

```
    # 외우기
    def search(st, en, target):
        if st == en:
            // ~~
            return

        mid = (st+en)//2
        if nums[mid] < target:
            search(mid +1, en, target)
        else:
            search(st,mid,target)
```

- TIP) 처음부터 생각하기 어려움, 쉬운방법부터 생각
- TIP) 입력 개수가 1e5(10^5->10만개)면 의심

# 그리디

- 현재 차례의 최고의 답을 찾는 문제
- 어려운 이유 : 증명하기가 어려움
- ex) 동전 여러개 있을 때 M원을 만드는 최소의 개수
- TIP) 그리디로 푸는 문제임을 생각하기 어려움
- TIP) 그리디 사용 이유 설명 or 반례 찾기 연습
